;----------------------------------------------------------------------
;PMACHASM.S
; The pseudo-machine which executes the object code generated by the SC
; compiler.
;----------------------------------------------------------------------

include macro.i

include debug.i
include debugasm.i
include errmsg.i
include pmachine.i

	.DATA

pmCode			label FuncPtr
pmCodeOffset	word		?
pmCodeSegment	word     ?

	.CODE		PM_TEXT

Dispatch	proc
;On entry:
;	ax = number of bytes of parameters passed
;	cx = script number
;	bx = entry number of procedure to execute

	;Save the instruction pointer, and pointers to the current local
	;variables.
   push  scriptHandle
ifdef DEBUG
   push  thisScript
   mov   thisScript, cx
endif
	push  es
	push	si
	push	localVar

	;Save the number of bytes of parameters passed.
	push	ax

	;Get the address of the code to execute.
	call	GetDispatchAddrInHunk
	mov	si, bx
	mov	di, ax
assume	di:ptr scriptNode
	mov   ax, [di].sHunk
	mov   scriptHandle, ax
	mov	ax, [di].sVars				;get address of local variables
	mov	localVar, ax
assume	di:nothing

	;Go execute the code.
	pop	ax								;recover the number of bytes of parameters
	call	DoCall

	;Restore the old module base, local variables, and scan pointer
	;within the module.
	pop	localVar
	pop	si
	pop   es
ifdef DEBUG
	pop   thisScript
endif
	pop   bx          				;script node hunk pointer
	mov	scriptHandle, bx
	UpdateScriptSeg
	ret

Dispatch	endp

DoCall	proc	near
;On entry:
;	ax =  number of bytes of parameters passed
;	es:si -> code to execute

	;Save relevant variables.
	push	parmVar	      			;save parameter base
	push	tempVar	      			;save temporary base

	;Set up the new parameter base.  The parameter base
	;is the (number of parameters) words below the current bp.
	;This is further decreased by the number of arguments put
	;on the stack by '&rest'.
	mov	bx, bp
	sub	bx, ax
   mov	ax, restArgs
	sub	bx, ax
	mov	parmVar, bx
	shr	ax, 1
	add	[bx], ax
   mov	restArgs, 0
	call	ExecuteCode

	;Restore the stack pointer to above the parameters, then restore
	;old variables.
	mov	bp, parmVar
	sub	bp, 2
	mov	pmsp, bp
	pop	tempVar
	pop	parmVar
	ret

DoCall	endp

;-------------------------------------------------------------------------
; GetDispatchAddrInHeapFromC  interface to GetDispatchAddrInHeap from C
;
; entry:	scriptNum	= script number
;        entry			= entry in script
; exit:  objPtrPtr	= pointer to pointer to object
;        scriptPtrPtr= pointer to pointer to script node
;-------------------------------------------------------------------------
GetDispatchAddrInHeapFromC proc	uses si \
											scriptNum:word, entry:word, \
											objPtrPtr:ptr ptr Obj, \
											scriptPtrPtr:ptr ptr scriptNode
	mov	cx, scriptNum
	mov	bx, entry
	call	GetDispatchAddrInHeap
	mov	si, objPtrPtr
	mov	[si], bx
	mov	si, scriptPtrPtr
	mov	[si], ax

	ret

GetDispatchAddrInHeapFromC	endp


GetDispatchAddr	proc	uses si di, scrptNde:word, entry:word
;Return a pointer to an entry in a script.

	mov	cx, scrptNde
	mov	bx, entry
	call	GetDispatchAddrInHeap
	mov	ax, bx
	ret

GetDispatchAddr	endp

GetDispatchAddrInHeap	proc	near
; Returns a pointer to the script node in heap and the address of
; a given external object in the heap.
;
;Input:
;	cx = script number
;	bx = entry number in script
;Output:
;	bx = address of object in heap
;	ax = address of script node in heap

	push  es
	push	bx
	invoke	ScriptPtr, cx
	mov	di, ax
	;get the handle for the hunk resource
	mov	bx, (scriptNode ptr [di]).sHunk
	;and dereference it to get the segment address
	mov   bx, (hunkPtr ptr [bx]).hSegment
	mov   es, bx
	xor	di, di
	lea	di, (hunkRes ptr [di]).hkNumDisp
	pop	bx

	;Get the number of entries in this dispatch table and check the
	;entry number which we are to call against it.
	.if	es:[di] >= bx
		;Index into the dispatch table with the entry number.
		shl	bx, 1
		mov	bx, es:[di+bx+2]					;get address of object from table
		pop	es
		UpdateScriptSeg
		ret
	.else
		pop   es
		invoke	PError, si, bp, E_BAD_DISPATCH, bx
	.endif

GetDispatchAddrInHeap	endp

GetDispatchAddrInHunk	proc	near
; Returns a pointer to the script node in heap and the address of
; the code for the external procedure in hunk.
;
;Input:
;	cx = script number
;	bx = entry number in script
;Output:
;  es = code segment
;	bx = object
;	ax = script

	call	GetDispatchAddrInHeap
 	mov	di, ax
	mov	di, (scriptNode ptr [di]).sHunk
	mov   di, (hunkPtr ptr [di]).hSegment
	mov   es, di
	return

GetDispatchAddrInHunk	endp

GetNewScript	proc	near
;loads script into heap and hunk
;input:
;  ax = script number

	push  bx         ;points to classTbl
	push  es
	push  si
	invoke	LoadScript, ax
	pop   si
	pop   es
	pop   bx
	UpdateScriptSeg
	ret

GetNewScript	endp

OP_ret_BYTE    equ   048h

NeedRetOpcode	proc	far
; taking previous es:si as instruction pointer
; because handle points to zero

ifdef DEBUG
	mov   defaultES, TRUE
	.if	scriptHandle && byte ptr es:[si] != OP_ret_BYTE
		;Save those registers which DOS wants saved.
		push  si
		push	es
		push	bx
		push	dx
		push	ds

		invoke	RAlert, E_DISPOSED_SCRIPT, thisScript

		;Restore the registers which DOS wants
		pop	ds
		pop	dx
		pop	bx
		call  DebugOn
		mov   trace, 1
		pop	es
		pop   si
	.endif
endif

	ret

NeedRetOpcode	endp

	end
